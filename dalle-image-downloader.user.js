// ==UserScript==
// @name         DALL-E 2 Batch Downloader
// @namespace    http://tampermonkey.net/
// @version      0.5
// @description  Batch download personal DALL-E 2 generated images with resume, manual index setting, and index display functionality
// @match        https://labs.openai.com/*
// @grant        GM_download
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_addStyle
// ==/UserScript==

(function() {
    'use strict';

    let isScrolling = false;
    let isDownloading = false;
    let stopDownloading = false;
    let lastProcessedIndex = GM_getValue('lastProcessedIndex', -1);

    // Add styles for the index display
    GM_addStyle(`
        .image-index-display {
            position: absolute;
            bottom: 5px;
            left: 5px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            z-index: 1000;
        }
    `);

    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function downloadImage(url, filename) {
        return new Promise((resolve, reject) => {
            GM_download({
                url: url,
                name: filename,
                onload: () => {
                    console.log(`Downloaded: ${filename}`);
                    resolve();
                },
                onerror: (error) => {
                    console.error(`Error downloading ${filename}:`, error);
                    reject(error);
                }
            });
        });
    }

    function sanitizeFilename(name) {
        return name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
    }

    async function processImages(startIndex = 0) {
        const images = document.querySelectorAll('.paginated-generations-item');
        for (let i = startIndex; i < images.length; i++) {
            if (stopDownloading) break;

            const item = images[i];
            const img = item.querySelector('img[alt="Generated by DALLÂ·E"]');
            const title = item.querySelector('.image-prompt-overlay h4');
            if (img && title) {
                const filename = `${sanitizeFilename(title.textContent)}_${i}.webp`;
                await downloadImage(img.src, filename);
                lastProcessedIndex = i;
                GM_setValue('lastProcessedIndex', lastProcessedIndex);
                await sleep(100); // 0.1 second delay between downloads
            }
        }
    }

    async function scrollToBottom() {
        if (isScrolling || stopDownloading) return;
        isScrolling = true;
        const scrollHeight = Math.max(
            document.body.scrollHeight, document.documentElement.scrollHeight,
            document.body.offsetHeight, document.documentElement.offsetHeight,
            document.body.clientHeight, document.documentElement.clientHeight
        );
        window.scrollTo(0, scrollHeight);
        await sleep(2000);
        isScrolling = false;
        if (document.body.scrollHeight > scrollHeight && !stopDownloading) {
            await processImages(lastProcessedIndex + 1);
            await scrollToBottom();
        } else if (!stopDownloading) {
            console.log("Finished downloading all images.");
            isDownloading = false;
            updateButtonStates();
        }
    }

    function addButtons() {
        const buttonContainer = document.createElement('div');
        buttonContainer.style.position = 'fixed';
        buttonContainer.style.top = '10px';
        buttonContainer.style.right = '10px';
        buttonContainer.style.zIndex = '9999';

        const startButton = document.createElement('button');
        startButton.textContent = 'Start Download';
        startButton.onclick = startDownload;
        buttonContainer.appendChild(startButton);

        const stopButton = document.createElement('button');
        stopButton.textContent = 'Stop Download';
        stopButton.onclick = stopDownload;
        stopButton.style.marginLeft = '10px';
        buttonContainer.appendChild(stopButton);

        const resumeButton = document.createElement('button');
        resumeButton.textContent = 'Resume Download';
        resumeButton.onclick = resumeDownload;
        resumeButton.style.marginLeft = '10px';
        buttonContainer.appendChild(resumeButton);

        const resetButton = document.createElement('button');
        resetButton.textContent = 'Reset Progress';
        resetButton.onclick = resetProgress;
        resetButton.style.marginLeft = '10px';
        buttonContainer.appendChild(resetButton);

        const indexInput = document.createElement('input');
        indexInput.type = 'number';
        indexInput.min = '0';
        indexInput.style.width = '100px';
        indexInput.style.marginLeft = '10px';
        buttonContainer.appendChild(indexInput);

        const setIndexButton = document.createElement('button');
        setIndexButton.textContent = 'Set Index';
        setIndexButton.onclick = () => setManualIndex(indexInput.value);
        setIndexButton.style.marginLeft = '10px';
        buttonContainer.appendChild(setIndexButton);

        document.body.appendChild(buttonContainer);

        return { startButton, stopButton, resumeButton, resetButton, indexInput, setIndexButton };
    }

    const { startButton, stopButton, resumeButton, resetButton, indexInput, setIndexButton } = addButtons();

    function updateButtonStates() {
        startButton.disabled = isDownloading;
        stopButton.disabled = !isDownloading;
        resumeButton.disabled = isDownloading || lastProcessedIndex === -1;
        resetButton.disabled = isDownloading;
        indexInput.disabled = isDownloading;
        setIndexButton.disabled = isDownloading;
    }

    async function startDownload() {
        if (isDownloading) return;
        isDownloading = true;
        stopDownloading = false;
        lastProcessedIndex = -1;
        GM_setValue('lastProcessedIndex', lastProcessedIndex);
        updateButtonStates();
        await processImages();
        await scrollToBottom();
    }

    function stopDownload() {
        stopDownloading = true;
        isDownloading = false;
        updateButtonStates();
        console.log("Stopping download after current image...");
    }

    async function resumeDownload() {
        if (isDownloading || lastProcessedIndex === -1) return;
        isDownloading = true;
        stopDownloading = false;
        updateButtonStates();
        await processImages(lastProcessedIndex + 1);
        await scrollToBottom();
    }

    function resetProgress() {
        lastProcessedIndex = -1;
        GM_setValue('lastProcessedIndex', lastProcessedIndex);
        updateButtonStates();
        console.log("Progress reset. Next download will start from the beginning.");
    }

    function setManualIndex(index) {
        const newIndex = parseInt(index, 10);
        if (isNaN(newIndex) || newIndex < 0) {
            alert("Please enter a valid non-negative number.");
            return;
        }
        lastProcessedIndex = newIndex - 1; // Subtract 1 because the script will start from the next index
        GM_setValue('lastProcessedIndex', lastProcessedIndex);
        console.log(`Index set to ${newIndex}. Next download will start from image ${newIndex}.`);
        updateButtonStates();
    }

    function addIndexesToImages() {
        const images = document.querySelectorAll('.paginated-generations-item');
        images.forEach((item, index) => {
            if (!item.querySelector('.image-index-display')) {
                const indexDisplay = document.createElement('div');
                indexDisplay.className = 'image-index-display';
                indexDisplay.textContent = index;
                item.style.position = 'relative';
                item.appendChild(indexDisplay);
            }
        });
    }

    // Initial call to add indexes
    addIndexesToImages();

    // Observe for new images being added
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            if (mutation.type === 'childList') {
                addIndexesToImages();
            }
        });
    });

    observer.observe(document.body, { childList: true, subtree: true });

    updateButtonStates();
})();
